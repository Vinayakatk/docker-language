/*
 * generated by Xtext
 */
package org.eclipse.docker.language.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.docker.language.container.Bind;
import org.eclipse.docker.language.container.Binding;
import org.eclipse.docker.language.container.BuildArgs;
import org.eclipse.docker.language.container.Container;
import org.eclipse.docker.language.container.ContainerPackage;
import org.eclipse.docker.language.container.Device;
import org.eclipse.docker.language.container.Docker;
import org.eclipse.docker.language.container.ExposedPort;
import org.eclipse.docker.language.container.Image;
import org.eclipse.docker.language.container.Label;
import org.eclipse.docker.language.container.Link;
import org.eclipse.docker.language.container.PortBinding;
import org.eclipse.docker.language.container.RestartPolicy;
import org.eclipse.docker.language.container.Ulimit;
import org.eclipse.docker.language.container.Volume;
import org.eclipse.docker.language.container.VolumesFrom;
import org.eclipse.docker.language.services.ContainerGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class ContainerSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ContainerGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ContainerPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ContainerPackage.BIND:
				sequence_Bind(context, (Bind) semanticObject); 
				return; 
			case ContainerPackage.BINDING:
				sequence_Binding(context, (Binding) semanticObject); 
				return; 
			case ContainerPackage.BUILD_ARGS:
				sequence_BuildArgs(context, (BuildArgs) semanticObject); 
				return; 
			case ContainerPackage.CONTAINER:
				sequence_Container(context, (Container) semanticObject); 
				return; 
			case ContainerPackage.DEVICE:
				sequence_Device(context, (Device) semanticObject); 
				return; 
			case ContainerPackage.DOCKER:
				sequence_Docker(context, (Docker) semanticObject); 
				return; 
			case ContainerPackage.EXPOSED_PORT:
				sequence_ExposedPort(context, (ExposedPort) semanticObject); 
				return; 
			case ContainerPackage.IMAGE:
				sequence_Image(context, (Image) semanticObject); 
				return; 
			case ContainerPackage.LABEL:
				sequence_Label(context, (Label) semanticObject); 
				return; 
			case ContainerPackage.LINK:
				sequence_Link(context, (Link) semanticObject); 
				return; 
			case ContainerPackage.PORT_BINDING:
				sequence_PortBinding(context, (PortBinding) semanticObject); 
				return; 
			case ContainerPackage.RESTART_POLICY:
				sequence_RestartPolicy(context, (RestartPolicy) semanticObject); 
				return; 
			case ContainerPackage.ULIMIT:
				sequence_Ulimit(context, (Ulimit) semanticObject); 
				return; 
			case ContainerPackage.VOLUME:
				sequence_Volume(context, (Volume) semanticObject); 
				return; 
			case ContainerPackage.VOLUMES_FROM:
				sequence_VolumesFrom(context, (VolumesFrom) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Bind returns Bind
	 *
	 * Constraint:
	 *     (location=STRING volume=Volume accessMode1=AccessMode?)
	 */
	protected void sequence_Bind(ISerializationContext context, Bind semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Binding returns Binding
	 *
	 * Constraint:
	 *     (hostIP=STRING hostPort=INT)
	 */
	protected void sequence_Binding(ISerializationContext context, Binding semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ContainerPackage.Literals.BINDING__HOST_IP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ContainerPackage.Literals.BINDING__HOST_IP));
			if (transientValues.isValueTransient(semanticObject, ContainerPackage.Literals.BINDING__HOST_PORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ContainerPackage.Literals.BINDING__HOST_PORT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBindingAccess().getHostIPSTRINGTerminalRuleCall_1_0(), semanticObject.getHostIP());
		feeder.accept(grammarAccess.getBindingAccess().getHostPortINTTerminalRuleCall_3_0(), semanticObject.getHostPort());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BuildArgs returns BuildArgs
	 *
	 * Constraint:
	 *     (key=STRING value=STRING)
	 */
	protected void sequence_BuildArgs(ISerializationContext context, BuildArgs semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ContainerPackage.Literals.BUILD_ARGS__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ContainerPackage.Literals.BUILD_ARGS__KEY));
			if (transientValues.isValueTransient(semanticObject, ContainerPackage.Literals.BUILD_ARGS__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ContainerPackage.Literals.BUILD_ARGS__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBuildArgsAccess().getKeySTRINGTerminalRuleCall_1_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getBuildArgsAccess().getValueSTRINGTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Container returns Container
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         image=STRING 
	 *         (
	 *             binds+=Bind | 
	 *             capabilityAdd+=Capability | 
	 *             capabilityDrop+=Capability | 
	 *             commands+=STRING | 
	 *             containerIDFile=STRING | 
	 *             cpuPeriod=INT | 
	 *             cpusetCpus=STRING | 
	 *             cpusetMems=STRING | 
	 *             cpuShares=INT | 
	 *             devices+=Device | 
	 *             dns+=STRING | 
	 *             dnsSearch+=STRING | 
	 *             domainName=STRING | 
	 *             entrypoint+=STRING | 
	 *             env+=STRING | 
	 *             exposedPorts+=ExposedPort | 
	 *             extraHosts+=STRING | 
	 *             labels+=Label | 
	 *             links+=Link | 
	 *             macAddress=STRING | 
	 *             memory=Elong | 
	 *             memorySwap=Elong | 
	 *             disableNetwork=EBoolean | 
	 *             networkMode=STRING | 
	 *             portBindings+=PortBinding | 
	 *             privileged=EBoolean | 
	 *             publishAllPorts=EBoolean | 
	 *             readonlyRootfs=EBoolean | 
	 *             pidMode=STRING | 
	 *             workingDir=STRING | 
	 *             user=STRING | 
	 *             tty=EBoolean | 
	 *             restartPolicy=RestartPolicy | 
	 *             volumes+=Volume | 
	 *             volumesFrom+=VolumesFrom | 
	 *             ulimits+=Ulimit
	 *         )*
	 *     )
	 */
	protected void sequence_Container(ISerializationContext context, Container semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Device returns Device
	 *
	 * Constraint:
	 *     (cGroupPermissions=STRING pathOnHost=STRING pathInContainer=STRING)
	 */
	protected void sequence_Device(ISerializationContext context, Device semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ContainerPackage.Literals.DEVICE__CGROUP_PERMISSIONS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ContainerPackage.Literals.DEVICE__CGROUP_PERMISSIONS));
			if (transientValues.isValueTransient(semanticObject, ContainerPackage.Literals.DEVICE__PATH_ON_HOST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ContainerPackage.Literals.DEVICE__PATH_ON_HOST));
			if (transientValues.isValueTransient(semanticObject, ContainerPackage.Literals.DEVICE__PATH_IN_CONTAINER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ContainerPackage.Literals.DEVICE__PATH_IN_CONTAINER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeviceAccess().getCGroupPermissionsSTRINGTerminalRuleCall_1_0(), semanticObject.getCGroupPermissions());
		feeder.accept(grammarAccess.getDeviceAccess().getPathOnHostSTRINGTerminalRuleCall_2_0(), semanticObject.getPathOnHost());
		feeder.accept(grammarAccess.getDeviceAccess().getPathInContainerSTRINGTerminalRuleCall_3_0(), semanticObject.getPathInContainer());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Docker returns Docker
	 *
	 * Constraint:
	 *     (containers+=Container | images+=Image)+
	 */
	protected void sequence_Docker(ISerializationContext context, Docker semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExposedPort returns ExposedPort
	 *
	 * Constraint:
	 *     (port=STRING protocol=InternalProtocol)
	 */
	protected void sequence_ExposedPort(ISerializationContext context, ExposedPort semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ContainerPackage.Literals.EXPOSED_PORT__PORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ContainerPackage.Literals.EXPOSED_PORT__PORT));
			if (transientValues.isValueTransient(semanticObject, ContainerPackage.Literals.EXPOSED_PORT__PROTOCOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ContainerPackage.Literals.EXPOSED_PORT__PROTOCOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExposedPortAccess().getPortSTRINGTerminalRuleCall_1_0(), semanticObject.getPort());
		feeder.accept(grammarAccess.getExposedPortAccess().getProtocolInternalProtocolEnumRuleCall_3_0(), semanticObject.getProtocol());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Image returns Image
	 *
	 * Constraint:
	 *     (
	 *         name=STRING 
	 *         (
	 *             tag=STRING | 
	 *             dockerFilelocation=STRING | 
	 *             buildargs=BuildArgs | 
	 *             noCache=EBoolean | 
	 *             memory=Elong | 
	 *             memswap=Elong | 
	 *             cpusetcpus=STRING | 
	 *             cpushares=STRING | 
	 *             remove=EBoolean | 
	 *             quiet=EBoolean | 
	 *             pull=EBoolean
	 *         )*
	 *     )
	 */
	protected void sequence_Image(ISerializationContext context, Image semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Label returns Label
	 *
	 * Constraint:
	 *     (key=STRING value=STRING)
	 */
	protected void sequence_Label(ISerializationContext context, Label semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ContainerPackage.Literals.LABEL__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ContainerPackage.Literals.LABEL__KEY));
			if (transientValues.isValueTransient(semanticObject, ContainerPackage.Literals.LABEL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ContainerPackage.Literals.LABEL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLabelAccess().getKeySTRINGTerminalRuleCall_0_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getLabelAccess().getValueSTRINGTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Link returns Link
	 *
	 * Constraint:
	 *     (containerLink=STRING alias=STRING)
	 */
	protected void sequence_Link(ISerializationContext context, Link semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ContainerPackage.Literals.LINK__CONTAINER_LINK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ContainerPackage.Literals.LINK__CONTAINER_LINK));
			if (transientValues.isValueTransient(semanticObject, ContainerPackage.Literals.LINK__ALIAS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ContainerPackage.Literals.LINK__ALIAS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLinkAccess().getContainerLinkSTRINGTerminalRuleCall_1_0(), semanticObject.getContainerLink());
		feeder.accept(grammarAccess.getLinkAccess().getAliasSTRINGTerminalRuleCall_3_0(), semanticObject.getAlias());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PortBinding returns PortBinding
	 *
	 * Constraint:
	 *     (binding=Binding exposedPort=[ExposedPort|STRING])
	 */
	protected void sequence_PortBinding(ISerializationContext context, PortBinding semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ContainerPackage.Literals.PORT_BINDING__BINDING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ContainerPackage.Literals.PORT_BINDING__BINDING));
			if (transientValues.isValueTransient(semanticObject, ContainerPackage.Literals.PORT_BINDING__EXPOSED_PORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ContainerPackage.Literals.PORT_BINDING__EXPOSED_PORT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPortBindingAccess().getBindingBindingParserRuleCall_1_0(), semanticObject.getBinding());
		feeder.accept(grammarAccess.getPortBindingAccess().getExposedPortExposedPortSTRINGTerminalRuleCall_2_0_1(), semanticObject.getExposedPort());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RestartPolicy returns RestartPolicy
	 *
	 * Constraint:
	 *     (value='always' | maximumRetryCount=INT)
	 */
	protected void sequence_RestartPolicy(ISerializationContext context, RestartPolicy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Ulimit returns Ulimit
	 *
	 * Constraint:
	 *     (name=STRING soft=INT hard=INT)
	 */
	protected void sequence_Ulimit(ISerializationContext context, Ulimit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ContainerPackage.Literals.ULIMIT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ContainerPackage.Literals.ULIMIT__NAME));
			if (transientValues.isValueTransient(semanticObject, ContainerPackage.Literals.ULIMIT__SOFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ContainerPackage.Literals.ULIMIT__SOFT));
			if (transientValues.isValueTransient(semanticObject, ContainerPackage.Literals.ULIMIT__HARD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ContainerPackage.Literals.ULIMIT__HARD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUlimitAccess().getNameSTRINGTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getUlimitAccess().getSoftINTTerminalRuleCall_2_0(), semanticObject.getSoft());
		feeder.accept(grammarAccess.getUlimitAccess().getHardINTTerminalRuleCall_3_0(), semanticObject.getHard());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Volume returns Volume
	 *
	 * Constraint:
	 *     path=STRING
	 */
	protected void sequence_Volume(ISerializationContext context, Volume semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ContainerPackage.Literals.VOLUME__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ContainerPackage.Literals.VOLUME__PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVolumeAccess().getPathSTRINGTerminalRuleCall_0(), semanticObject.getPath());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VolumesFrom returns VolumesFrom
	 *
	 * Constraint:
	 *     (container=STRING accessMode=AccessMode?)
	 */
	protected void sequence_VolumesFrom(ISerializationContext context, VolumesFrom semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
